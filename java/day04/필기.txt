1. 반복문
 1-1. while문
  - while문 역시 for문과 마찬가지로 반복적인 
  처리를 수행하는 문법
  - for문은 초기식, 조건식, 증감식을 모두 내장하는
  반면, while문은 조건식만을 내장하기 때문에 
  초기식과 증감식을 외부에 따로 정의해 주어야 한다. 

	초기식;
	while(조건식){
		.. 반복적으로 동작할 구문 ..
		증감식;
	}

 1-2. do~while문
  - 조건의 판별을 나중에 수행하는 반복문 형태
  - 초기식을 설정한 후 do{...}안에 문장을
  우선적으로 1회 실행하고 조건을 판별하므로, 
  조건이 참이 아니더라도 최소 1회는 실행된다. 

	초기식;
	do{
		.. 반복적으로 동작할 구문 ..		증감식;
	} while(조건식);

 1-3. 무한루프
  - 증감식이 설정되지 않거나, 증감식이 수행되더라도
  조건식이 거짓이 되지 않는 형태
  - 조건식이 항상 참이므로, 반복문이 종료되지
  않는다.
  - 프로그램이 PC의 자원을 매우 많으 상용하게
  되므로, 시스템 다운을 발생시킬 수 있다. 
  - for문의 무한루프 예
	for(int i=0; i<10; i--){
		System.out.println(i);
	}

  - while문의 무한루프 예
	while(true){
		System.out.println("Hello");
	}

2. 변수의 범위
 2-1. 변수의 범위(=변수의 스코프)
  - 자신보다 하위 블록으로 침투할 수 있다.
  
	int num = 100;
	if(num == 100){
		// num이 현재 블록의 바깥에서
		// 선언되었으므로 유효
		System.out.println(num);
	}
	------------------------------------
	int num = 100;
	for(int i=0; i<10; i++){
		// 변수 num이 현재 블록 밖에서
		// 생성되었으므로 사용가능
		System.out.println(num+i);
	}
	
  - 자신이 선언된 블록 밖으로는 빠져나갈 수 없다.
	
	int num = 100;
	if(num == 100){
		int result = num + 100;
	}
	// 변수 result가 if블록 안에서 생성되었으므로
	// 사용불가
	System.out.println(result);
	------------------------------------------
	for(int i=0; i<10; i++){
		...
	}
	// i가 for문을 위한 괄호 안에서 사용되었으므로
	// 사용불가
	System.out.println(i);
	
  - 블록안에서 선언된 변수는 블록 밖에서 존재하는 
  동일한 이름의 변수와는 이름만 동일할 뿐, 다른 값으로 
  인식된다.

	int target = 100;
	if(target == 100){
		int num = target + 100;
	} else {
		int num = target - 100;
	}


3. 여러가지 문법의 중첩 사용
  - 앞서 살펴본 문법들은 서로 중첩해서 사용하는 것이 가능

4. 반복문에서의 break와 continue
 - break : 반복문 안에서 break 키워드를 만나면 반복을
	    강제 종료
 - continue : 실행흐름이 증감식으로 강제 이동
 
5. 배열
 5-1. 배열이란?
  - 변수를 그룹으로 묶은 형태의 한 종류로서, 사물함 같은
  형태를 갖고 있다.
  - 하나의 배열안에는 같은 종류(데이터 형)의 값들만
  저장될 수 있다. 
 
 5-2. 배열을 만드는 방법
  - 배열의 선언
	데이터형[] 배열이름;

  - 배열의 생성 - 변수를 저장할 수 있는 사물함을 생성
	배열이름 = new 데이터형[크기];

 - 배열의 생성의 예
	int[] grade;
	grade = new int[3];

 - 배열의 선언과 크기 지정에 대한 일괄처리
	데이터형[] 배열이름 = new 데이터형[크기];
	int[] grade = new int[3];

 5-3. 배열의 모양
    - 생성된 배열은 사물함과 같이 각각의 칸에 값들이 저장
    되고, 각각의 칸은 0부터 일련번호가 지정된다.
    (일련번호 = 배열의 인덱스)

 5-4. 배열의 값을 저장하기
  -  배열은 값을 저장할 수 있는 공간일 뿐, 그 자체가 값은
  아니다
  - 값이 대입되지 않은 경우, 숫자형은 0, boolean형은
  false가 자동으로 대입된다.
  - 배열안에 값을 저장하기 위해서는 인덱스 번호를 사용하여
  각각의 칸에 직접 값을 대입해야 한다. 
	배열이름[인덱스] = 값;
	
  - 둘리의 점수를 배열로 표현
	int[] grade = new int[3];
	grade[0] = 75;
	grade[1] = 82;
	grade[2] = 91;

 - 배열의 크기 설정과 값 할당에 대한 일괄처리
	-> 배열의 크기를 지정하면 괄호"{...}"안에
	배열에 포함될 각 항목들은 콤마(,)로 
	나열하면, 배열의 생성과 값의 할당을 일괄처리할
 	수 있다. 이때 배열의 크기를 별도로 지정하지
	않으며, "new 데이터형[]"부분은 생략

	데이터형[] 배열이름 = 
	  new 데이터형[]{값1, 값2, 값3, .. , 값n};
	----------------------------------------
	데이터형[] 배열이름 = 
	  {값1, 값2, 값3, .. , 값n};
	
 5-5. 배열값 사용하기
  - 배열안에 저장되어 있는 값들을 사용하여 연산이나
  출력등의 처리를 위해서는 배열에 부여된 인덱스 값을
  통해서 데이터에 접근해야 한다. 
	System.out.println(grade[0]);
	System.out.println(grade[1]);
	System.out.println(grade[2]);

 5-6. 배열과 반복문
  - 배열의 특성
 	: 0~(배열 크기 -1)만큼의 인덱스 값을 순차적으로
	갖는다.
  - 특성을 활용한 배열 데이터의 처리
	: 일정 범위를 갖고 순차적으로 증가하는 인덱스
	값의 특성을 활용하면 반복문 안에서 배열의 
	값을 할당하거나, 할당된 값을 읽어들이는 처리가
	가능하다. 

	for(int i=0; i<3; i++){
		System.out.println(grade[i]);
	}

 5-7. 배열의 크기(길이)
  - 배열의 길이를 얻기 위해서는 "배열이름.lengh"형식으로
 접근한다. 
	int size = grade.length;

6. 2차원 배열
 6-1. 배열의 종류
  - 1차 배열
	-> 앞에서 살펴본 배열처럼 한 줄만 존재하는 
	사물함 같이 구성된 배열
	-> 행에 대한 개념이 없고, 열에 대한 개념만 존재
	하기 때문에 "배열이름.lengh"는 몇 칸인지를 
 	알아보는 기능이 된다.
  - 2차 배열
	-> 1차 배열의 각 칸에 새로운 배열을 넣는 형태
	-> 1차 배열의 각 칸은 행이 되고, 각각의 칸에 
	추가된 개별적인 배열이 "열"의 개념이 되어
	"행렬"을 구성하게 된다. 
  - 다차원 배열
	-> 배열의 각 칸에 지속적으로 다른 형태의 배열을
	포함시키는 형태로서 2차, 3차, 4차, n차까지 
	무제한으로 확장할 수 있다.
	-> 실무에서는 2차원 배열을 초과하는 형태는
	사용하지 않는다. 




 6-2. 2차원 배열의 선언
  - 데이터 타입의 이름뒤에 대괄호"[][]"를 행과 열에 
  대하여 각각 지정한다
	데이터형[][] 배열이름;

 - 2차원 배열의 크기 할당
	-> 행과 열에 대한 크기를 명시한다
	배열이름 = new 데이터형[행][열];

 - 2차원 배열의 선언과 할당의 일괄처리
	데이터형[][] 배열이름 = 
		new 데이터형[행][열];
	------------------------------------
	int[][] grade = new int[3][3];

 6-3. 2차원 배열에 대한 값의 대입 방법
  - 행,열에 대한 인덱스를 통합하여 값을 대입한다.
	배열이름[행][열] = 값;

 6-4. 일괄지정하는 방법
  	int[][] grade = new int[][]{
		{75, 82, 91}
		{88, 64, 50},
		{100, 100, 90}
	};

 6-5. 2차원 배열의 길이
  - 2차원 배열의 길이는 행에 대한 측면과 열에 대한 측면을
  나누어서 생각해야 한다. 
  - 행의 길이
	int rows = grade.length;
  - 열의 길이
	int cols = grade[행].length;










